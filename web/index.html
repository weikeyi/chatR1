<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>简洁对话框</title>
    <style>
      body {
        background-color: #f5f5f5;
        display: flex;
        flex-direction: column;
        height: 100vh;
        margin: 0;
        font-family: Arial, sans-serif;
      }
      .chat-container {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .message {
        max-width: 60%;
        padding: 10px;
        border-radius: 15px;
        font-size: 16px;
      }
      .user-message {
        align-self: flex-end;
        background-color: #007bff;
        color: white;
      }
      .server-message {
        align-self: flex-start;
        background-color: #e9ecef;
        color: black;
      }
      .input-container {
        display: flex;
        align-items: center;
        background-color: #fff;
        border: 1px solid #ddd;
        border-radius: 25px;
        padding: 10px;
        width: 500px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        margin: 20px auto;
      }
      .input-field {
        flex: 1;
        border: none;
        outline: none;
        font-size: 16px;
        padding: 5px 10px;
        border-radius: 20px;
      }
      .send-button {
        background-color: transparent;
        border: none;
        cursor: pointer;
        padding: 5px;
        font-size: 16px;
      }
    </style>
  </head>
  <body>
    <div class="chat-container" id="chatContainer">
      <!-- 对话内容将动态添加 -->
    </div>
    <div class="input-container">
      <input
        type="text"
        class="input-field"
        id="inputField"
        placeholder="输入你的问题..."
      />
      <button class="send-button" onclick="sendMessage()">发送</button>
    </div>

    <script>
      const chatContainer = document.getElementById('chatContainer');
      const inputField = document.getElementById('inputField');

      async function fetchSSE(url, onMessage, options) {
        let reader;
        const decoder = new TextDecoder('utf-8');
        let buffer = '';
        let fullMessage = '';
        const controller = new AbortController();
        options.signal = controller.signal;
        try {
          const response = await fetch(url, options);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          if (!response.body) {
            throw new Error('响应体为空');
          }
          reader = response.body.getReader();
          function processSSEmessage(messages) {
            let event = 'message';
            const lines = messages.split('\n');

            for (const line of lines) {
              const trimmedLine = line.trim();
              if (!trimmedLine) continue; //忽略空行

              if (line.startsWith('data:')) {
                const message = line.substring(5).trim();
                if (message) {
                  let parsedMessage = message;
                  try {
                    parsedMessage = JSON.parse(message); // 仅解析 data 内容
                    if (
                      parsedMessage.choices &&
                      parsedMessage.choices[0]?.delta?.content
                    ) {
                      fullMessage += parsedMessage.choices[0].delta.content;
                      onMessage({ event, message: fullMessage }); // 实时更新拼接后的内容
                      if (
                        parsedMessage.choices &&
                        parsedMessage.choices[0]?.finish_reason === 'stop'
                      ) {
                        onMessage({ event: 'done', message: fullMessage }); // 流结束事件
                        controller.abort(); // 停止流
                      }
                    }
                  } catch (e) {
                    console.warn('Failed to parse JSON:', e);
                  }
                  onMessage({ event, message: parsedMessage });
                }
              } else if (line.startsWith('event:')) {
                event = line.substring(6).trim();
              } else {
                onMessage({ event, message: lines });
              }
            }
          }
          async function processStream() {
            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              buffer += decoder.decode(value, { stream: true });
              let separatorIndex;
              while ((separatorIndex = buffer.indexOf('\n\n')) >= 0) {
                const messages = buffer.substring(0, separatorIndex);
                buffer = buffer.substring(separatorIndex + 2);
                processSSEmessage(messages);
              }
            }
          }
          await processStream();
        } catch (error) {
          // 错误处理
          onMessage({
            event: 'error',
            message: `Error in fetchSSE: ${error.message}`,
          });
          throw error; // 抛出错误以便调用者处理
        } finally {
          if (reader) {
            await reader.cancel();
          }
        }
        return {
          abort: () => controller.abort(),
        };
      }

      function sendMessage() {
        const messageText = inputField.value.trim();
        if (!messageText) return;

        // 添加用户消息（右侧）
        const userMessage = document.createElement('div');
        userMessage.classList.add('message', 'user-message');
        userMessage.textContent = messageText;
        chatContainer.appendChild(userMessage);

        // 添加服务器消息（左侧）
        const severMessage = fetchSSE(
          'http://localhost:3000/chat',
          ({ event, message }) => {
            const serverMessage = document.createElement('div');
            serverMessage.classList.add('message', 'server-message');
            serverMessage.textContent = message;
            chatContainer.appendChild(serverMessage);
          },
          {
            method: 'POST',
            body: JSON.stringify({ message: messageText }),
            headers: {
              'Content-Type': 'application/json',
            },
          },
        );

        // 清空输入框
        inputField.value = '';

        // 滚动到底部
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }

      // 按回车键发送
      inputField.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          sendMessage();
        }
      });
    </script>
  </body>
</html>
